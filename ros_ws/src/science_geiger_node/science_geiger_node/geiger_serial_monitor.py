#!/usr/bin/env python3

#Create a geiger publishing node and have it publish to a new /geiger topic. 


"""

Generated by Claude

UART Serial Monitor for Geiger Counter Data
Monitors TTL serial data at 115200 baud from XLR3 connector
Expected data: ASCII decimal numbers separated by unix-style newlines (0x0A)
Sample rate: ~10 samples per second
"""

import serial
import time
import argparse
import sys
import rclpy
from rclpy.node import Node
from std_msgs.msg import Int32  
from datetime import datetime
import threading 

class GeigerSerialMonitor(Node):
    def __init__(self, port, baudrate=115200, timeout=1):

        #node 
        super().__init__('geiger_publisher_node') 

        """
        Initialize the serial monitor
        
        Args:
            port (str): Serial port name (e.g., 'COM3' on Windows, '/dev/ttyUSB0' on Linux)
            baudrate (int): Baud rate (default 115200)
            timeout (float): Read timeout in seconds
        """
        self.port = port
        self.baudrate = baudrate
        self.timeout = timeout
        self.serial_conn = None
        self.running = False

        self.publisher = self.create_publisher(Int32, '/geiger', 10)
        self.start_time = time.time() 
        
    def connect(self):
        """Establish serial connection"""
        try:
            self.serial_conn = serial.Serial(
                port=self.port,
                baudrate=self.baudrate,
                bytesize=serial.EIGHTBITS,
                parity=serial.PARITY_NONE,
                stopbits=serial.STOPBITS_ONE,
                timeout=self.timeout,
                xonxoff=False,
                rtscts=False,
                dsrdtr=False
            )
            print(f"Connected to {self.port} at {self.baudrate} baud")
            return True
        except serial.SerialException as e:
            print(f"Error connecting to {self.port}: {e}")
            return False
    
    def disconnect(self):
        """Close serial connection"""
        if self.serial_conn and self.serial_conn.is_open:
            self.serial_conn.close()
            print("Serial connection closed")
    
    def publish_geiger_count(self, geiger_count): 
        msg = Int32()
        msg.data = geiger_count
        self.publisher.publish(msg)

    def monitor(self, log_file=None, display_raw=False, display_stats=True):
        """
        Start monitoring serial data
        
        Args:
            log_file (str): Optional file path to log data
            display_raw (bool): Show raw data bytes
            display_stats (bool): Show running statistics
        """
        if not self.connect():
            return
        
        self.running = True
        sample_count = 0
        total_counts = 0
        start_time = time.time()
        last_stats_time = start_time
        
        # Open log file if specified
        log_handle = None
        if log_file:
            try:
                log_handle = open(log_file, 'w')
                log_handle.write("timestamp,count_value\n")  # CSV header
                print(f"Logging data to: {log_file}")
            except IOError as e:
                print(f"Error opening log file: {e}")
        
        print("\n--- Starting Geiger Counter Monitor ---")
        print("Press Ctrl+C to stop")
        print("Expected: ASCII decimal numbers at ~10 samples/second")
        print("-" * 50)
        
        buffer = ""
        
        try:
            while self.running:
                if self.serial_conn.in_waiting > 0:
                    # Read available data
                    data = self.serial_conn.read(self.serial_conn.in_waiting)
                    
                    if display_raw:
                        print(f"Raw bytes: {data}")
                    
                    # Decode and add to buffer
                    try:
                        text_data = data.decode('ascii', errors='ignore')
                        buffer += text_data
                        
                        # Process complete lines (ending with \n)
                        while '\n' in buffer:
                            line, buffer = buffer.split('\n', 1)
                            line = line.strip()
                            
                            if line:  # Skip empty lines
                                timestamp = datetime.now()
                                
                                try:
                                    # Parse as decimal number
                                    count_value = int(line)
                                    sample_count += 1
                                    total_counts += count_value
                                    
                                    # Display the reading
                                    print(f"{timestamp.strftime('%H:%M:%S.%f')[:-3]} | Count: {count_value:6d} | Sample: {sample_count}")
                                    
                                    #Publish to Ros topic
                                    self.publish_geiger_count(count_value) #publishing to ros super quickly. 

                                    # Log to file if enabled
                                    if log_handle:
                                        log_handle.write(f"{timestamp.isoformat()},{count_value}\n")
                                        log_handle.flush()
                                        
                                except ValueError:
                                    print(f"{timestamp.strftime('%H:%M:%S.%f')[:-3]} | Invalid data: '{line}'")
                    
                    except UnicodeDecodeError as e:
                        print(f"Decode error: {e}")
                
                # Display statistics every 10 seconds
                current_time = time.time()
                # if display_stats and (current_time - last_stats_time) >= 10:
                #     elapsed = current_time - start_time
                #     if sample_count > 0:
                #         avg_rate = sample_count / elapsed
                #         avg_count = total_counts / sample_count
                #         print(f"\n--- Stats (Runtime: {elapsed:.1f}s) ---")
                #         print(f"Samples received: {sample_count}")
                #         print(f"Average sample rate: {avg_rate:.2f} Hz")
                #         print(f"Average count value: {avg_count:.2f}")
                #         print(f"Total counts: {total_counts}")
                #         print("-" * 40)
                #     last_stats_time = current_time
                
                # Small delay to prevent CPU spinning
                time.sleep(0.01)
                
        except KeyboardInterrupt:
            print("\nStopping monitor...")
            self.running = False
        
        except Exception as e:
            print(f"Error during monitoring: {e}")
        
        finally:
            # Cleanup
            if log_handle:
                log_handle.close()
                print(f"Data logged to: {log_file}")
            
            self.disconnect()
            
            # Final statistics
            if sample_count > 0:
                elapsed = time.time() - start_time
                print(f"\n--- Final Statistics ---")
                print(f"Total runtime: {elapsed:.1f} seconds")
                print(f"Total samples: {sample_count}")
                print(f"Average sample rate: {sample_count/elapsed:.2f} Hz")
                print(f"Total counts: {total_counts}")
                print(f"Average count per sample: {total_counts/sample_count:.2f}")

def list_serial_ports():
    """List available serial ports"""
    import serial.tools.list_ports
    ports = serial.tools.list_ports.comports()
    if ports:
        print("Available serial ports:")
        for port in ports:
            print(f"  {port.device} - {port.description}")
    else:
        print("No serial ports found")

def main():
    parser = argparse.ArgumentParser(description='Monitor Geiger Counter serial data')
    parser.add_argument('port', nargs='?', help='Serial port (e.g., COM3, /dev/ttyUSB0)')
    parser.add_argument('-b', '--baudrate', type=int, default=115200, help='Baud rate (default: 115200)')
    parser.add_argument('-l', '--log', help='Log data to CSV file')
    parser.add_argument('-r', '--raw', action='store_true', help='Display raw byte data')
    parser.add_argument('--no-stats', action='store_true', help='Disable periodic statistics')
    parser.add_argument('--list-ports', action='store_true', help='List available serial ports')
    
    args = parser.parse_args()
    
    rclpy.init(args=None) 

    if args.list_ports:
        list_serial_ports()
        return
    
    if not args.port:
        print("Error: Serial port not specified. Provide with --port")
        print("\nUse --list-ports to see available ports")
        list_serial_ports()
        return
    
    # Create and start monitor

    node = GeigerSerialMonitor(args.port, args.baudrate) 
    try:
        # Start monitoring in a separate thread so ROS2 can spin
        monitor_thread = threading.Thread(
            target=node.monitor,
            args=(args.log, args.raw, not args.no_stats)
        )
        monitor_thread.daemon = True
        monitor_thread.start()
        
        # Spin the node to handle ROS2 callbacks
        rclpy.spin(node)

    finally:
        # Cleanup
        node.destroy_node()
        rclpy.shutdown()
if __name__ == "__main__":
    main()